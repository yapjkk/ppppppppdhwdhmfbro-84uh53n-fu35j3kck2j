# send_threaded.py
from time import sleep
import threading
from concurrent.futures import ThreadPoolExecutor
from functions.email_utils import maybe_send_test_copy
import random
import smtplib
from functions.send_email import send_email
# Removed pause/resume functionality for simplicity
from functions import loader
from functions.fmswitch import get_next_sender, get_next_sender_name, get_next_subject
from functions.placeholders import replace_placeholders
from functions.email_logger import log_failed_email, log_sent_email, remove_email_from_emails_txt, get_log_summary
from functions.smtp_load_balancer import get_load_balancer, reset_load_balancer, parse_time_string
from colored import fg, attr
from colorama import init, Fore, Style
import time
import os
import textwrap
import quopri
from email.header import decode_header

# Initialize Colorama
init()

# Define bronze-inspired color variables
COLOR_PRIMARY = Fore.YELLOW
COLOR_HEADER = Fore.LIGHTYELLOW_EX
COLOR_ACCENT_GREEN = Fore.GREEN
COLOR_ACCENT_RED = Fore.RED
COLOR_ACCENT_CYAN = Fore.CYAN
COLOR_ACCENT_YELLOW = Fore.YELLOW
COLOR_TEXT = Fore.WHITE
COLOR_HIGHLIGHT = Fore.LIGHTYELLOW_EX
COLOR_SF_YELLOW = Fore.YELLOW
COLOR_SF_LIGHTYELLOW = Fore.LIGHTYELLOW_EX
COLOR_SF_WHITE = Fore.WHITE
COLOR_SECONDARY = Fore.LIGHTGREEN_EX
COLOR_TABLE_BORDER = Fore.LIGHTCYAN_EX
COLOR_SF_CONNECTING = Fore.BLUE
COLOR_SF_REUSED = Fore.GREEN
COLOR_SF_DISCONNECTED = Fore.RED
STYLE_BOLD = Style.BRIGHT
STYLE_RESET = Style.RESET_ALL

def truncate_email(email, width=15):
    """Truncate email to fit within specified width."""
    if len(email) > width:
        return email[:width-3] + "..."
    return email.ljust(width)

def wrap_text(text, width=15):
    """Wrap or truncate text to fit within specified width."""
    if text.startswith('=?utf-8?b?') or text.startswith('=?UTF-8?b?'):
        try:
            decoded = decode_header(text)[0][0]
            if isinstance(decoded, bytes):
                text = decoded.decode('utf-8')
            else:
                text = decoded
        except:
            pass
    
    wrapped = textwrap.shorten(text, width=width, placeholder="...")
    return wrapped.ljust(width)

def generate_colored_ascii_table(from_email, sender_name, smtp_section, email_subject, email, 
                               current_sender_num=1, total_senders=1, 
                               current_email_num=1, total_emails=1, connection_status="disconnected", 
                               success_count=0):
    """Generate a colored ASCII table for email status with connection status indicator."""
    smtp_section = wrap_text(smtp_section, width=7)
    from_email = truncate_email(from_email, width=15)
    sender_name = wrap_text(sender_name, width=15)
    email_subject = wrap_text(email_subject, width=27)
    email = truncate_email(email, width=25)
    
    sender_counter = f"{current_sender_num}/{total_senders}"
    # Use success_count for the sequential count in ASCII art
    email_counter = f"{success_count}/{total_emails}"
    
    # Set color for S.F indicator based on connection status
    if connection_status == "connecting":
        sf_color = COLOR_SF_CONNECTING
    elif connection_status == "reused":
        sf_color = COLOR_SF_REUSED
    else:  # disconnected
        sf_color = COLOR_SF_DISCONNECTED
    
    # Build complete ASCII table as single string to prevent threading issues
    table_lines = [
        f"│ {COLOR_TABLE_BORDER}╭───────┬─────────────────┬─────────────────┬──────────────────────────────┬────╮  {COLOR_PRIMARY}│",
        f"{COLOR_PRIMARY}│ {COLOR_TABLE_BORDER}│{STYLE_BOLD}{COLOR_HEADER}SMTP   │   FROMAIL       {STYLE_RESET}{COLOR_TABLE_BORDER}│ {STYLE_BOLD}{COLOR_HEADER}  From Name     {STYLE_RESET}{COLOR_TABLE_BORDER}│{STYLE_BOLD}{COLOR_HEADER}          Subject             {STYLE_RESET}{COLOR_TABLE_BORDER}│{STYLE_BOLD}{COLOR_HEADER}S.F{STYLE_RESET} {COLOR_TABLE_BORDER}│{COLOR_PRIMARY}  │",
        f"{COLOR_PRIMARY}│{COLOR_TABLE_BORDER} ├───────┼─────────────────┼─────────────────┼──────────────────────────────┼────┤ {COLOR_PRIMARY} │",
        f"{COLOR_PRIMARY}│ {COLOR_TABLE_BORDER}│{COLOR_TEXT}{smtp_section}│ {from_email:<15} │ {sender_name:<15} │ {email_subject:<27}  │ {sf_color}●{COLOR_TABLE_BORDER}  │  {COLOR_PRIMARY}│",
        f"{COLOR_PRIMARY}│ {COLOR_TABLE_BORDER}├───────┴─────────────────┴─────────────────┴──────────────────────────────┴────╯  {COLOR_PRIMARY}│",
        f"{COLOR_PRIMARY}│ {COLOR_TABLE_BORDER}│      ╭───────────────────────────────────────────┬─────────────────╮             {COLOR_PRIMARY}│",
        f"{COLOR_PRIMARY}│ {COLOR_TABLE_BORDER}╰──────◎   Email  sent to {COLOR_HIGHLIGHT}{email}{STYLE_RESET}{COLOR_TABLE_BORDER}│{COLOR_SECONDARY}  {email_counter:<9}{COLOR_TABLE_BORDER}      │             {COLOR_PRIMARY}│",
        f"{COLOR_PRIMARY}│    {COLOR_TABLE_BORDER}    ╰───────────────────────────────────────────┴─────────────────╯             {COLOR_PRIMARY}│"
    ]
    
    # Return complete table as single string for atomic printing
    return '\n'.join(table_lines)


def print_email_status(from_email, sender_name, smtp_section, email_subject, email, 
                      current_sender_num=1, total_senders=1, 
                      current_email_num=1, total_emails=1, connection_status="disconnected",
                      success_count=0, show_ascii_table=True):
    """Print email status using colored ASCII table with connection status or simple line."""
    with print_lock:
        if show_ascii_table:
            # Generate the complete table as a single string
            table_string = generate_colored_ascii_table(
                from_email, sender_name, smtp_section, email_subject, email,
                current_sender_num, total_senders,
                current_email_num, total_emails, connection_status, success_count
            )
            # Print the entire table at once - completely atomic
            print(table_string)
        else:
            # Simple single-line output
            email_display = email[:30] + "..." if len(email) > 30 else email
            print(f"{COLOR_ACCENT_GREEN}✓{STYLE_RESET} Email {success_count}/{total_emails} sent to {COLOR_TEXT}{email_display}{STYLE_RESET} ({COLOR_TEXT}{from_email[:20]}{STYLE_RESET})")

email_lock = threading.Lock()
print_lock = threading.Lock()  # Lock for preventing duplicate prints
email_sent_count = 0
shared_connections = {}
connection_locks = {}
emails_sent_per_smtp = {}
CONNECTION_RESET_INTERVAL = 999  # Disable frequent resets - only reset at countsend threshold

# Global pause mechanism
global_pause_event = threading.Event()
global_pause_event.set()  # Initially not paused
pause_lock = threading.Lock()

# Permanently disabled SMTP servers (due to authentication errors)
permanently_disabled_smtp = set()

# Global load balancer instance
_global_load_balancer = None

def is_smtp_permanently_disabled(smtp_section):
    """Check if an SMTP server is permanently disabled due to authentication errors."""
    return smtp_section in permanently_disabled_smtp

def permanently_disable_smtp(smtp_section, reason="Authentication error"):
    """Permanently disable an SMTP server and print notification."""
    global permanently_disabled_smtp
    with email_lock:
        permanently_disabled_smtp.add(smtp_section)
        print(f"🚫 Permanently disabled {smtp_section}: {reason}")

def get_available_smtp_servers():
    """Get list of SMTP servers that are not permanently disabled."""
    return [smtp for smtp in loader.smtp_servers if not is_smtp_permanently_disabled(smtp)]

def get_next_available_smtp_server(server_index):
    """Get the next available SMTP server, skipping permanently disabled ones."""
    available_servers = get_available_smtp_servers()
    if not available_servers:
        raise ConnectionError("❌ All SMTP servers are permanently disabled due to authentication errors")
    return available_servers[server_index % len(available_servers)]

def close_all_connections():
    """Close all existing SMTP connections to free up connection slots."""
    global shared_connections
    with email_lock:
        for smtp_section, conn in list(shared_connections.items()):
            try:
                conn.quit()
            except:
                pass
        shared_connections.clear()
        # Reset all email counters
        global emails_sent_per_smtp
        emails_sent_per_smtp.clear()

def create_connection(smtp_section):
    """Create a new SMTP connection."""
    # Check if SMTP is permanently disabled
    if is_smtp_permanently_disabled(smtp_section):
        raise ConnectionError(f"❌ {smtp_section} is permanently disabled due to authentication errors")
    
    smtp_host = loader.config_parser.get(smtp_section, 'host')
    smtp_port = loader.config_parser.getint(smtp_section, 'port')
    smtp_user = loader.config_parser.get(smtp_section, 'user')
    smtp_password = loader.config_parser.get(smtp_section, 'password')
    smtp_type = loader.config_parser.get(smtp_section, 'type', fallback='tls').lower()

    try:
        if smtp_type == 'ssl':
            conn = smtplib.SMTP_SSL(smtp_host, smtp_port, timeout=30)
        else:
            conn = smtplib.SMTP(smtp_host, smtp_port, timeout=30)
            conn.starttls()
        conn.ehlo()
        conn.login(smtp_user, smtp_password)
        return conn, "connecting"
    except Exception as e:
        # Check for authentication errors (535 error code)
        error_str = str(e).lower()
        if "535" in str(e) and ("authentication" in error_str or "credentials" in error_str or "invalid" in error_str):
            # Permanently disable this SMTP server due to authentication error
            permanently_disable_smtp(smtp_section, f"Authentication failed: {e}")
            raise ConnectionError(f"❌ {smtp_section} permanently disabled due to authentication error")
        
        # Create ASCII art error message
        error_msg = f"❌ SMTP Connection creation failed for [{smtp_section}]: {e}"
        error_lines = textwrap.wrap(error_msg, width=71)
        
        print("│  ╭───────────────────────────────────────────────────────────────────────────╮     │")
        for line in error_lines:
            # Pad line to 75 characters and center it
            padded_line = line.ljust(70)
            print(f"│  │  {padded_line}  │     │")
        print("│  ╰───────────────────────────────────────────────────────────────────────────╯     │")
        
        # Check for configurable error code that triggers connection reset
        smtp_config = loader.config.get("smtp_connection", {})
        smart_management = smtp_config.get("smart_connection_management", False)
        exceed_code = smtp_config.get("exceed_code", 421)
        
        if smart_management and (str(exceed_code) in str(e) or "too many connections" in str(e).lower() or "service not available" in str(e).lower()):
            print(f"🔄 Error code {exceed_code} detected in create_connection, closing all connections and retrying...")
            close_all_connections()
            # Wait a bit before retrying
            sleep(3)
        
        # Record failure in global load balancer
        global _global_load_balancer
        if _global_load_balancer:
            _global_load_balancer.record_failure(smtp_section, str(e))
        
        return None, "disconnected"

def get_connection(smtp_section, reuse):
    """Get or create an SMTP connection, handling reuse logic."""
    if smtp_section not in connection_locks:
        connection_locks[smtp_section] = threading.Lock()
    
    with connection_locks[smtp_section]:
        emails_sent = emails_sent_per_smtp.get(smtp_section, 0)

        if reuse:
            # Force new connection every CONNECTION_RESET_INTERVAL emails
            if emails_sent > 0 and emails_sent % CONNECTION_RESET_INTERVAL == 0:
                if smtp_section in shared_connections:
                    try:
                        shared_connections[smtp_section].quit()
                    except:
                        pass
                    del shared_connections[smtp_section]
                conn, status = create_connection(smtp_section)
                if conn is None:
                    raise ConnectionError(f"🚫 Fresh SMTP connection failed for {smtp_section}")
                shared_connections[smtp_section] = conn
                return conn, status

        if reuse:
            conn = shared_connections.get(smtp_section)
            if conn:
                try:
                    conn.noop()
                    return conn, "reused"
                except Exception as e:
                    try:
                        conn.quit()
                    except:
                        pass
                    if smtp_section in shared_connections:
                        del shared_connections[smtp_section]
                    conn, status = create_connection(smtp_section)
                    if conn:
                        shared_connections[smtp_section] = conn
                    else:
                        raise ConnectionError(f"❌ Could not re-establish connection to {smtp_section}")
                    return conn, status

        # No reuse or no existing connection
        conn, status = create_connection(smtp_section)
        if conn is None:
            raise ConnectionError(f"❌ Could not create connection for {smtp_section}")
        if reuse:
            shared_connections[smtp_section] = conn
        return conn, status

def send_email_with_retries(smtp_section, email, from_email, smtp_connection=None, sender_name=None, email_subject=None, current_sender_num=1, total_senders=1, current_email_num=1, total_emails=1, load_balancer=None):
    """Send an email with retry logic and print status."""
    global email_sent_count
    threading_config = loader.config.get("threading", {})
    retries = threading_config.get("retry", {}).get("count", 5)
    delay_base = threading_config.get("retry", {}).get("delay_base", 2)
    test_email = loader.config.get("sending_settings", {}).get("test_email")
    reuse = loader.config.get("smtp_connection", {}).get("reuse", False)
    display_config = loader.config.get("display", {})
    show_ascii_table = display_config.get("show_ascii_table", True)
    

    for attempt in range(1, retries + 1):
        try:
            if smtp_connection is None:
                smtp_connection, connection_status = get_connection(smtp_section, reuse)
                if smtp_connection is None:
                    raise ConnectionError(f"🚫 Unable to obtain a valid SMTP connection for {smtp_section}")
            else:
                connection_status = "connecting" if not reuse else "reused"

            if smtp_connection is None:
                connection_status = "disconnected"
                raise ConnectionError(f"🛑 smtp_connection still None before send_email call")

            # Get the config folder from environment variable
            config_folder = os.environ.get('FEXSENDER_SELECTED_FOLDER', '')
            if not config_folder:
                # Fallback: use default
                config_folder = "configs/IONOS"  # fallback to IONOS
            
            smtp_connection, actual_sender_name, actual_email_subject = send_email(
                smtp_section, email, from_email, smtp_connection, sender_name, email_subject, loader, config_folder
            )
            # Only print status once on successful send
            # Note: Count will be displayed after success check in the main loop
            print_email_status(from_email, actual_sender_name, smtp_section, actual_email_subject, email, current_sender_num, total_senders, current_email_num, total_emails, connection_status, email_sent_count + 1, show_ascii_table)
            
            # Record success in load balancer
            if load_balancer:
                load_balancer.record_success(smtp_section)
            
            # Increment email count and handle test emails
            with email_lock:
                email_sent_count += 1
                emails_sent_per_smtp[smtp_section] = emails_sent_per_smtp.get(smtp_section, 0) + 1
                
                # Success message is now included in ASCII art
                test_email = loader.config.get("sending_settings", {}).get("test_email")
                if email != test_email:
                    maybe_send_test_copy(
                        count=email_sent_count,
                        test_email=test_email,
                        email_data={
                            "smtp_section": smtp_section,
                            "from_email": from_email,
                            "count_send": loader.config.get("sending_settings", {}).get("test_email_interval", 10),
                            "smtp_connection": smtp_connection,
                            "original_email": email
                        },
                        send_logic=send_email
                    )
            
            
            return True
        except Exception as e:
            connection_status = "disconnected"
            
            # Check for connection limit errors
            error_str = str(e)
            smtp_config = loader.config.get("smtp_connection", {})
            smart_management = smtp_config.get("smart_connection_management", False)
            
            # Check if it's a "Mails per session limit exceeded" error
            if "Mails per session limit exceeded" in error_str or "mails per session limit exceeded" in error_str.lower():
                print(f"🔄 Session limit exceeded for {smtp_section}, forcing connection reset...")
                # Force connection reset by closing and removing the connection
                if smtp_section in shared_connections:
                    try:
                        shared_connections[smtp_section].quit()
                    except:
                        pass
                    del shared_connections[smtp_section]
                # Reset the counter
                emails_sent_per_smtp[smtp_section] = 0
            
            # Check for configurable error code that triggers connection reset
            if smart_management:
                smtp_config = loader.config.get("smtp_connection", {})
                exceed_code = smtp_config.get("exceed_code", 421)
                
                # Check if the error contains the configured error code
                if str(exceed_code) in error_str or "too many connections" in error_str.lower() or "service not available" in error_str.lower():
                    print(f"🔄 Error code {exceed_code} detected, closing all connections and retrying...")
                    close_all_connections()
                    # Wait a bit before retrying
                    sleep(3)
            
            # Record failure in load balancer
            if load_balancer:
                load_balancer.record_failure(smtp_section, str(e))
            
            if attempt < retries:
                sleep(delay_base * attempt)
            else:
                # Show detailed error message in console
                error_details = f"❌ Failed to send {email} after {retries} attempts"
                error_details += f"\n   Error: {str(e)}"
                error_details += f"\n   SMTP: {smtp_section}"
                print(error_details)
                
                # Log the final failure after all retries
                log_failed_email(
                    email=email,
                    error_message=f"Failed after {retries} attempts: {str(e)}",
                    smtp_section=smtp_section,
                    from_email=from_email,
                    sender_name=sender_name,
                    email_subject=email_subject,
                    attempt=attempt,
                    max_attempts=retries
                )
                return False

def open_terminal_for_sending():
    """Open a new terminal window for email sending."""
    try:
        import subprocess
        import sys
        
        # Check if running as executable (.exe)
        if getattr(sys, 'frozen', False):
            # Running as executable - use the executable path
            main_script = sys.executable
        else:
            # Running as Python script - use current working directory
            main_script = os.path.join(os.getcwd(), 'main.py')
            if not os.path.exists(main_script):
                # Fallback to relative path from current script
                script_path = os.path.abspath(__file__)
                main_script = os.path.join(os.path.dirname(script_path), '..', 'main.py')
                main_script = os.path.abspath(main_script)
        
        
        # Get the selected folder from environment
        selected_folder = os.environ.get('FEXSENDER_SELECTED_FOLDER', '').strip()
        
        # If we don't have a selected folder, we can't proceed
        if not selected_folder:
            print(f"{COLOR_ACCENT_RED}❌ No project folder selected. Cannot open new terminal.{STYLE_RESET}")
            return False
        
        # Prepare environment variables
        env_vars = "FEXSENDER_TERMINAL_MODE=true"
        env_vars += f" FEXSENDER_SELECTED_FOLDER={selected_folder}"
        
        # Determine the appropriate command based on the operating system
        if sys.platform.startswith('win'):
            # Windows - use cmd with proper escaping and quoting
            script_dir = os.path.dirname(main_script)
            if getattr(sys, 'frozen', False):
                # Running as executable - call the executable directly
                cmd = f'start cmd /k "cd /d "{script_dir}" && set FEXSENDER_TERMINAL_MODE=true && set FEXSENDER_SELECTED_FOLDER={selected_folder} && echo Environment set && "{main_script}""'
            else:
                # Running as Python script - use python command
                cmd = f'start cmd /k "cd /d "{script_dir}" && set FEXSENDER_TERMINAL_MODE=true && set FEXSENDER_SELECTED_FOLDER={selected_folder} && echo Environment set && python "{main_script}""'
        elif sys.platform.startswith('darwin'):
            # macOS - use Terminal.app
            if getattr(sys, 'frozen', False):
                # Running as executable
                cmd = f'osascript -e "tell application \\"Terminal\\" to do script \\"cd {os.path.dirname(main_script)} && FEXSENDER_TERMINAL_MODE=true FEXSENDER_SELECTED_FOLDER={selected_folder} {main_script}\\""'
            else:
                # Running as Python script
                cmd = f'osascript -e "tell application \\"Terminal\\" to do script \\"cd {os.path.dirname(main_script)} && FEXSENDER_TERMINAL_MODE=true FEXSENDER_SELECTED_FOLDER={selected_folder} python {main_script}\\""'
        else:
            # Linux - use xterm or gnome-terminal
            if getattr(sys, 'frozen', False):
                # Running as executable
                cmd = f'gnome-terminal -- bash -c "cd {os.path.dirname(main_script)} && FEXSENDER_TERMINAL_MODE=true FEXSENDER_SELECTED_FOLDER={selected_folder} {main_script}; exec bash"'
            else:
                # Running as Python script
                cmd = f'gnome-terminal -- bash -c "cd {os.path.dirname(main_script)} && FEXSENDER_TERMINAL_MODE=true FEXSENDER_SELECTED_FOLDER={selected_folder} python {main_script}; exec bash"'
        
        # Create a terminal mode file to help the new terminal detect it's in terminal mode
        terminal_mode_file = os.path.join(os.path.dirname(main_script), "fexsender_terminal_mode.flag")
        with open(terminal_mode_file, 'w') as f:
            f.write(f"Terminal mode: {selected_folder}")
        
        # Execute the command
        subprocess.Popen(cmd, shell=True)
        print(f"{COLOR_PRIMARY}🚀 Opening new terminal window for email sending...{STYLE_RESET}")
        print(f"{COLOR_PRIMARY}📁 Project folder: {selected_folder}{STYLE_RESET}")
        return True
    except Exception as e:
        print(f"{COLOR_ACCENT_RED}❌ Failed to open new terminal: {e}{STYLE_RESET}")
        return False

def send_emails_threaded(open_terminal=False):
    """Main function to send emails using threading."""
    global email_sent_count
    
    # Check if we're running in a new terminal window (prevent infinite recursion)
    if os.environ.get('FEXSENDER_TERMINAL_MODE', 'false').lower() == 'true':
        # We're in the new terminal, proceed with email sending
        pass
    else:
        # We're in the original terminal
        if open_terminal:
            # Open new terminal for sending
            # Ready to send emails
            if open_terminal_for_sending():
                # New terminal window opened
                return  # Exit this process, let the new terminal handle sending
            else:
                print(f"{COLOR_ACCENT_RED}⚠️  Failed to open new terminal, running in current window...{STYLE_RESET}")
        else:
            # Don't open terminal, just send emails directly
            pass
    
    # Removed redundant calls: Configurations are already loaded by load_all_configs() in main.py
    # loader.load_yaml_config()
    # loader.load_smtp_config()
    # loader.load_emails()
    # loader.load_sender_emails()

    # Simple email sending without pause/resume complexity

    threading_config = loader.config.get("threading", {})
    reuse = loader.config.get("smtp_connection", {}).get("reuse", False)
    enabled_raw = threading_config.get("enabled")
    threading_enabled = str(enabled_raw).strip().lower() in ["1", "true", "yes", "on"]

    max_threads = threading_config.get("max_threads", 5)
    delay = threading_config.get("delay", 0)
    smtp_sequential_mode = threading_config.get("smtp_sequential_mode", False)
    
    # Store original max_threads for reference
    original_max_threads = max_threads
    
    # Initialize SMTP Load Balancer
    circuit_breaker_config = loader.config.get("smtp_circuit_breaker", {})
    circuit_breaker_enabled = circuit_breaker_config.get("enabled", False)
    load_balancer = None
    if circuit_breaker_enabled:
        # Pass the SMTP servers list to the load balancer
        config_with_servers = loader.config.copy()
        config_with_servers["smtp_servers"] = loader.smtp_servers
        load_balancer = get_load_balancer(config_with_servers)
        
        # Set global load balancer for use in create_connection
        global _global_load_balancer
        _global_load_balancer = load_balancer
    
    switch_count = threading_config.get("fromemail_switch", {}).get("count", 20)
    fromname_switch_count = threading_config.get("fromname_switch", {}).get("count", 1)
    subject_switch_count = threading_config.get("subject_switch", {}).get("count", 1)
    retries = threading_config.get("retry", {}).get("count", 5)
    delay_base = threading_config.get("retry", {}).get("delay_base", 2)
    sending_limit = threading_config.get("sending_limit", float('inf'))  # Default to no limit
    use_sending_limit = threading_config.get("use_sending_limit", False)  # Default to False

    server_index = from_email_index = 0
    total_senders = len(loader.sender_emails)
    total_emails = len(loader.emails)
    # Determine the maximum number of emails to send based on the sending limit toggle
    max_emails_to_send = min(sending_limit, total_emails) if use_sending_limit else total_emails
    

    if threading_enabled:
        # Adjust thread count based on healthy SMTP servers if load balancer is enabled
        if load_balancer and circuit_breaker_config.get("adjust_threads_dynamically", False):
            recommended_threads = load_balancer.get_recommended_thread_count(loader.smtp_servers, original_max_threads)
            if recommended_threads != max_threads:
                # Create ASCII art for thread adjustment message
                thread_msg = f"🔄 Adjusting threads: {max_threads} → {recommended_threads} (based on {recommended_threads} healthy SMTP servers)"
                thread_lines = textwrap.wrap(thread_msg, width=70)
                print("│  ╭───────────────────────────────────────────────────────────────────────────╮     │")
                for line in thread_lines:
                    padded_line = line.ljust(71)
                    print(f"│  │  {padded_line}  │     │")
                print("│  ╰───────────────────────────────────────────────────────────────────────────╯     │")
                max_threads = recommended_threads
        
        
        # Get pause settings to limit batch size
        pause_settings = loader.config.get("pause_settings", {})
        pause_enabled = pause_settings.get("enabled", False)
        max_send = pause_settings.get("max_send", 10) if pause_enabled else max_threads
        
        # Use smaller batch size if pause is enabled to respect the threshold
        effective_batch_size = min(max_threads, max_send) if pause_enabled else max_threads
        
        with ThreadPoolExecutor(max_threads) as executor:
            # Process emails in batches for true concurrency
            all_futures = []
            for batch_start in range(0, max_emails_to_send, effective_batch_size):
                # Check if we need to adjust thread count mid-execution
                if load_balancer and circuit_breaker_config.get("adjust_threads_dynamically", False):
                    recommended_threads = load_balancer.get_recommended_thread_count(loader.smtp_servers, original_max_threads)
                    if recommended_threads != max_threads:
                        # Create ASCII art for mid-execution thread adjustment message
                        mid_thread_msg = f"🔄 Mid-execution thread adjustment: {max_threads} → {recommended_threads} (based on {recommended_threads} healthy SMTP servers)"
                        mid_thread_lines = textwrap.wrap(mid_thread_msg, width=70)
                        print("│  ╭───────────────────────────────────────────────────────────────────────────╮     │")
                        for line in mid_thread_lines:
                            padded_line = line.ljust(71)
                            print(f"│  │  {padded_line}  │     │")
                        print("│  ╰───────────────────────────────────────────────────────────────────────────╯     │")
                        max_threads = recommended_threads
                
                batch_futures = []
                
                # Process up to effective_batch_size emails simultaneously
                for i in range(batch_start, min(batch_start + effective_batch_size, max_emails_to_send)):
                    email = loader.emails[i]
                    
                    # Select SMTP server using load balancer or fallback to sequential mode
                    if load_balancer:
                        # Use load balancer with circuit breaker
                        available_servers = get_available_smtp_servers()
                        smtp_section = load_balancer.get_next_server(available_servers)
                        if smtp_section is None:
                            print("⚠️ No healthy SMTP servers available, skipping email")
                            continue
                    elif smtp_sequential_mode:
                        # Use different SMTP server for each email in the batch to avoid blocking
                        smtp_section = get_next_available_smtp_server(i)
                    else:
                        # Use different SMTP server for each email to avoid blocking on same server
                        smtp_section = get_next_available_smtp_server(i)

                    if loader.config_parser.has_option(smtp_section, 'from_email'):
                        smtp_from_email = loader.config_parser.get(smtp_section, 'from_email').strip()
                    else:
                        smtp_from_email = None

                    if smtp_from_email == "##RANDOMFROMEMAIL##":
                        try:
                            from_email = get_next_sender()
                        except Exception as e:
                            available_senders = [e.split("/")[0].strip() for e in loader.sender_emails]
                            if not available_senders:
                                raise ValueError("No sender emails available.")
                            from_email = random.choice(available_senders)
                    elif smtp_from_email:
                        # Check if from_email contains placeholders and process them
                        if "##RANDOM_STRING_LOWER_" in smtp_from_email or "##RANDOM_STRING_UPPER_" in smtp_from_email or "##RANDOM_NUMBER_" in smtp_from_email:
                            from_email = replace_placeholders(smtp_from_email, email, "", loader.config)
                        else:
                            from_email = smtp_from_email
                    else:
                        raise ValueError(f"No 'from_email' set in [{smtp_section}] and no fallback logic defined.")

                    current_sender_num = (server_index % total_senders) + 1
                    # Fetch sender_name and email_subject based on email_sent_count
                    sender_name = get_next_sender_name() if i % fromname_switch_count == 0 else sender_name
                    email_subject = get_next_subject() if i % subject_switch_count == 0 else email_subject

                    # Submit email to thread pool - let send_email_with_retries handle all retry logic
                    batch_futures.append(executor.submit(
                        send_email_with_retries, 
                        smtp_section, 
                        email, 
                        from_email, 
                        None,  # Let send_email_with_retries get its own connection
                        sender_name, 
                        email_subject, 
                        current_sender_num, 
                        total_senders, 
                        i + 1,  # Thread index - will be updated with global count in send_email_with_retries
                        max_emails_to_send,
                        load_balancer
                    ))

                    with email_lock:
                        if i % switch_count == 0:
                            from_email_index = (from_email_index + 1) % len(loader.sender_emails)
                
                # Wait for this batch to complete before starting next batch
                for future in batch_futures:
                    try:
                        future.result()  # Wait for completion
                    except Exception as e:
                        print(f"❌ Error in batch processing: {e}")
                
                # Check for pause after each batch
                pause_settings = loader.config.get("pause_settings", {})
                if pause_settings.get("enabled", False):
                    max_send = pause_settings.get("max_send", 10)
                    pause_time_str = pause_settings.get("pause_time", "1m")
                    pause_time = parse_time_string(pause_time_str)
                    
                    # Check if we've reached the pause threshold
                    if email_sent_count >= max_send and email_sent_count % max_send == 0:
                        print(f"\n{COLOR_ACCENT_YELLOW}⏸️  PAUSE: Reached {max_send} emails sent. Pausing for {pause_time} seconds ({pause_time_str})...{STYLE_RESET}")
                        print(f"{COLOR_ACCENT_YELLOW}📊 Total emails sent so far: {email_sent_count}{STYLE_RESET}")
                        
                        # Pause for the specified time
                        for remaining in range(pause_time, 0, -1):
                            print(f"\r{COLOR_ACCENT_YELLOW}⏳ Resuming in {remaining} seconds...{STYLE_RESET}", end="", flush=True)
                            sleep(1)
                        
                        print(f"\n{COLOR_ACCENT_GREEN}▶️  Resuming email sending...{STYLE_RESET}\n")
                
                # Add delay between batches (except for the last batch)
                if batch_start + effective_batch_size < max_emails_to_send and delay > 0:
                    sleep(delay)
                    server_index = (server_index + 1) % len(loader.smtp_servers)

            # All batches completed
    else:
        sender_name = None
        email_subject = None
        while email_sent_count < max_emails_to_send:
            # Apply delay between emails (except for the first one)
            if email_sent_count > 0 and delay > 0:
                sleep(delay)
            
            email = loader.emails[email_sent_count]
            
            # Select SMTP server using load balancer or fallback to sequential mode
            if load_balancer:
                # Use load balancer with circuit breaker
                available_servers = get_available_smtp_servers()
                smtp_section = load_balancer.get_next_server(available_servers)
                if smtp_section is None:
                    print("⚠️ No healthy SMTP servers available, skipping email")
                    continue
            elif smtp_sequential_mode:
                # Use different SMTP server for each email
                smtp_section = get_next_available_smtp_server(email_sent_count)
            else:
                # Use the same SMTP server for all emails
                smtp_section = get_next_available_smtp_server(server_index)

            if loader.config_parser.has_option(smtp_section, 'from_email'):
                smtp_from_email = loader.config_parser.get(smtp_section, 'from_email').strip()
            else:
                smtp_from_email = None

            if smtp_from_email == "##RANDOMFROMEMAIL##":
                try:
                    from_email = get_next_sender()
                except Exception as e:
                    available_senders = [e.split("/")[0].strip() for e in loader.sender_emails]
                    if not available_senders:
                        raise ValueError("No sender emails available.")
                    from_email = random.choice(available_senders)
            elif smtp_from_email:
                # Check if from_email contains placeholders and process them
                if "##RANDOM_STRING_LOWER_" in smtp_from_email or "##RANDOM_STRING_UPPER_" in smtp_from_email or "##RANDOM_NUMBER_" in smtp_from_email:
                    from_email = replace_placeholders(smtp_from_email, email, "", loader.config)
                else:
                    from_email = smtp_from_email
            else:
                raise ValueError(f"No 'from_email' set in [{smtp_section}] and no fallback logic defined.")

            current_sender_num = (server_index % total_senders) + 1
            current_email_num = email_sent_count + 1
            # Fetch sender_name and email_subject based on email_sent_count
            sender_name = get_next_sender_name() if email_sent_count % fromname_switch_count == 0 else sender_name
            email_subject = get_next_subject() if email_sent_count % subject_switch_count == 0 else email_subject

            success = False
            for attempt in range(1, retries + 1):
                try:
                    smtp_conn, connection_status = get_connection(smtp_section, reuse)
                    if smtp_conn is None:
                        # Connection failed, record in load balancer and log as failed email
                        if load_balancer:
                            load_balancer.record_failure(smtp_section, "SMTP connection failed")
                        
                        log_failed_email(
                            email=email,
                            error_message=f"SMTP connection failed for {smtp_section}",
                            smtp_section=smtp_section,
                            from_email=from_email,
                            sender_name=sender_name,
                            email_subject=email_subject,
                            attempt=attempt,
                            max_attempts=retries
                        )
                        if attempt < retries:
                            sleep(delay_base * attempt)
                        else:
                            break
                    else:
                        success = send_email_with_retries(
                            smtp_section, 
                            email, 
                            from_email, 
                            smtp_conn, 
                            sender_name, 
                            email_subject, 
                            current_sender_num, 
                            total_senders, 
                            current_email_num, 
                            max_emails_to_send,
                            load_balancer
                        )
                        if success:
                            break
                except Exception as e:
                    # Show detailed error message in console
                    error_msg = f"Connection error: {str(e)}"
                    print(f"❌ {error_msg} - Email: {email} - SMTP: {smtp_section}")
                    
                    # Log connection error as failed email
                    log_failed_email(
                        email=email,
                        error_message=error_msg,
                        smtp_section=smtp_section,
                        from_email=from_email,
                        sender_name=sender_name,
                        email_subject=email_subject,
                        attempt=attempt,
                        max_attempts=retries
                    )
                    if attempt < retries:
                        sleep(delay_base * attempt)
                    else:
                        break

            if success:
                pass  # Counting is now handled in send_email_with_retries function

            with email_lock:
                if email_sent_count % switch_count == 0:
                    from_email_index = (from_email_index + 1) % len(loader.sender_emails)
                server_index = (server_index + 1) % len(loader.smtp_servers)

    # Display completion message
    print(f"{COLOR_PRIMARY}│                                                                                    │{STYLE_RESET}")
    print(f"{COLOR_PRIMARY}╰────────────────────────────────────────────────────────────────────────────────────╯{STYLE_RESET}")

    for conn in shared_connections.values():
        try:
            conn.quit()
        except:
            pass
    
    # Email sending completed
    print("\n" + "="*60)
    print(get_log_summary())
    print("="*60)
    

if __name__ == "__main__":
    send_emails_threaded()