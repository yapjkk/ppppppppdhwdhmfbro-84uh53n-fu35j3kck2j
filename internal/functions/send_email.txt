import os
import tempfile
import smtplib
import subprocess
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from email.mime.base import MIMEBase
from email import encoders
from email.encoders import encode_base64, encode_quopri
from functions import loader
from functions.placeholders import replace_placeholders
from functions.email_utils import encode_header
from functions.b2riad import generate_email_headers, generate_advanced_email_headers
from functions.email_logger import log_failed_email, log_sent_email, remove_email_from_emails_txt
from bs4 import BeautifulSoup
import base64
import urllib.request
import ssl
import certifi
from PyPDF2 import PdfReader, PdfWriter
import random
import string

# Define Unicode ranges for zcode encoding
JAPANESE_RANGE = [chr(i) for i in range(0x3041, 0x3097)]  # Hiragana
KOREAN_RANGE = [chr(i) for i in range(0xAC00, 0xD7A3)]  # Hangul
CHINESE_RANGE = [chr(i) for i in range(0x4E00, 0x9FFF)]  # Hanzi
ARABIC_RANGE = [chr(i) for i in range(0x0600, 0x06FF)]  # Arabic
RUSSIAN_RANGE = [chr(i) for i in range(0x0400, 0x04FF)]  # Cyrillic (Russian)
GREEK_RANGE = [chr(i) for i in range(0x0370, 0x03FF)]   # Greek

# Punnnycode characters - visually identical homographs
PUNNNYCODE_RANGE = [
    'А', 'В', 'С', 'Ꭰ', 'Е', 'Ғ', 'Ꮐ', 'Ꮋ', 'І', 'Ꭻ', 'Κ', 'Ꮮ', 'Μ', 'Ν', 'Ο', 'Ρ', 'Ԛ', 'Ꭱ', 'Տ', 'Τ', 'Ս', 'Ꮩ', 'Ԝ', 'Χ', 'Υ', 'Ζ',  # Uppercase
    'а', 'Ꮟ', 'с', 'Ꮷ', 'е', 'ɡ', 'і', 'ј', 'κ', 'ⅼ', 'ⅿ', 'ο', 'р', 'ԛ', 'ѕ', 'υ', 'ω', 'х', 'у', 'z'  # Lowercase
]

def is_smtp_connection_valid(smtp_connection):
    """Check if the SMTP connection is valid."""
    try:
        smtp_connection.noop()
        return True
    except Exception:
        return False

def zcode_with_language(html_content, char_range):
    """
    Apply zcode obfuscation to HTML content using a specific character range.
    Args:
        html_content (str): HTML content as a string.
        char_range (list): List of characters to use for obfuscation.
    Returns:
        str: Modified HTML content with zcode obfuscation applied.
    """
    try:
        soup = BeautifulSoup(html_content, 'html.parser')
        if not soup.body:
            soup = BeautifulSoup(f"<html><body>{html_content}</body></html>", 'html.parser')
        if not soup.body:
            return html_content
        for text_node in soup.body.find_all(string=True, recursive=True):
            if text_node.strip() and text_node.parent.name not in ['script', 'style']:
                # Skip DONTencrypt content - check if parent has the DONTencrypt styling
                parent_style = text_node.parent.get('style', '') if text_node.parent else ''
                if 'font-size: 1px' in parent_style and 'color: #f3f3f3' in parent_style:
                    # This is DONTencrypt content, skip it
                    continue
                
                words = text_node.strip().split(' ')
                new_content = []
                for word in words:
                    # Surround each character with 4 zcode chars before and 4 after
                    word_with_obfuscation = ''
                    for char in word:
                        # Generate 4 random chars before
                        before_chars = ''.join(random.choice(char_range) for _ in range(4))
                        before_span = soup.new_tag('span', style='font-size:0px;color:transparent')
                        before_span.string = before_chars
                        
                        # Generate 4 random chars after
                        after_chars = ''.join(random.choice(char_range) for _ in range(4))
                        after_span = soup.new_tag('span', style='font-size:0px;color:transparent')
                        after_span.string = after_chars
                        
                        # Combine: 4 zcode + real char + 4 zcode
                        word_with_obfuscation += str(before_span) + char + str(after_span)
                    
                    new_content.append(word_with_obfuscation)
                    new_content.append(' ')
                new_text = ''.join(new_content).strip()
                new_soup = BeautifulSoup(new_text, 'html.parser')
                parent = text_node.parent
                text_node.replace_with(*new_soup.contents)
        return str(soup)
    except Exception:
        return html_content

def zcode_japanese(html_content):
    return zcode_with_language(html_content, JAPANESE_RANGE)

def zcode_korean(html_content):
    return zcode_with_language(html_content, KOREAN_RANGE)

def zcode_chinese(html_content):
    return zcode_with_language(html_content, CHINESE_RANGE)

def zcode_arabic(html_content):
    return zcode_with_language(html_content, ARABIC_RANGE)

def zcode_russian(html_content):
    return zcode_with_language(html_content, RUSSIAN_RANGE)

def zcode_greek(html_content):
    return zcode_with_language(html_content, GREEK_RANGE)

def zcode_punnnycode(html_content):
    return zcode_with_language(html_content, PUNNNYCODE_RANGE)

def zcode(html_content):
    return zcode_with_language(html_content, string.ascii_uppercase + string.digits)

def html_to_pdf_raw(html_content, output_path, options=None):
    """Convert HTML content to PDF using wkhtmltopdf."""
    with tempfile.NamedTemporaryFile(delete=False, suffix=".raw.html") as tmp_raw_html:
        tmp_raw_html.write(html_content.encode("utf-8"))
        raw_html_path = tmp_raw_html.name
    soup = BeautifulSoup(html_content, 'html.parser')
    for tag in soup.find_all(True, href=True):
        href = tag.get('href', '')
        if href == 'about:blank' or href.startswith('##') or not href:
            tag['href'] = ''
    for tag in soup.find_all(True, src=True):
        src = tag.get('src', '')
        if src == 'about:blank' or src == 'COMPANYLOGO' or src.startswith('##') or not src:
            tag.decompose()
    html_content = str(soup)
    options = options or {}
    wkhtmltopdf_path = r"C:\Program Files\wkhtmltopdf\bin\wkhtmltopdf.exe"
    if not os.path.exists(wkhtmltopdf_path):
        raise FileNotFoundError(f"wkhtmltopdf not found at: {wkhtmltopdf_path}")
    args = [
        wkhtmltopdf_path,
        "--quiet",
        "--disable-javascript",
        "--page-size", options.get("page-size", "A4"),
        "--orientation", options.get("orientation", "Portrait"),
        "--zoom", str(options.get("zoom", 1.0)),
        "--margin-top", options.get("margin-top", "10mm"),
        "--margin-right", options.get("margin-right", "10mm"),
        "--margin-bottom", options.get("margin-bottom", "10mm"),
        "--margin-left", options.get("margin-left", "10mm"),
    ]
    if options.get("print-media-type", "true") == "true":
        args.append("--print-media-type")
    if options.get("disable-smart-shrinking", "false") == "true":
        args.append("--disable-smart-shrinking")
    args.extend(["-", output_path])
    args = [arg for arg in args if arg]
    try:
        process = subprocess.Popen(args, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE)
        stdout, stderr = process.communicate(input=html_content.encode("utf-8"))
        if process.returncode != 0:
            raise RuntimeError(f"wkhtmltopdf failed: {stderr.decode()}")
        if os.path.exists(output_path) and os.path.getsize(output_path) > 0:
            os.remove(raw_html_path)
        else:
            raise RuntimeError("PDF file creation failed")
    except Exception as e:
        raise

def encrypt_pdf(input_path, output_path, password):
    """Encrypt a PDF file with a password using PyPDF2."""
    try:
        if not os.path.exists(input_path):
            raise FileNotFoundError(f"Input PDF not found: {input_path}")
        with open(input_path, 'rb') as file:
            reader = PdfReader(file)
            if reader.is_encrypted:
                return False
            writer = PdfWriter()
            for page in reader.pages:
                writer.add_page(page)
            writer.encrypt(user_password=password, owner_password=None, use_128bit=True)
            with open(output_path, 'wb') as output_file:
                writer.write(output_file)
        if os.path.exists(output_path) and os.path.getsize(output_path) > 0:
            with open(output_path, 'rb') as file:
                reader = PdfReader(file)
                if reader.is_encrypted:
                    return True
                else:
                    return False
        else:
            return False
    except Exception:
        raise

def clear_image_cache():
    """Clear the global image cache"""
    if hasattr(embed_images, '_image_cache'):
        embed_images._image_cache.clear()

def embed_images(html_content, config):
    """Simple fast image embedding with basic caching"""
    image_encode = config["message_encode"].get("image_encode", "none").lower()
    if image_encode != "base64":
        return html_content
    
    # Simple global cache
    if not hasattr(embed_images, '_image_cache'):
        embed_images._image_cache = {}
    
    context = ssl.create_default_context(cafile=certifi.where())
    try:
        soup = BeautifulSoup(html_content, 'html.parser')
        
        for img in soup.find_all('img'):
            src = img.get('src')
            if not src or src.startswith('data:') or src == 'COMPANYLOGO':
                continue
            
            # Check cache first
            if src in embed_images._image_cache:
                if embed_images._image_cache[src] is not None:
                    img['src'] = embed_images._image_cache[src]
                continue
            
            try:
                # Load image data
                if src.startswith('http'):
                    with urllib.request.urlopen(src, context=context, timeout=3) as response:
                        img_data = response.read()
                else:
                    with open(src, 'rb') as f:
                        img_data = f.read()
                
                # Encode to base64 directly - no optimization overhead
                img_base64 = base64.b64encode(img_data).decode('utf-8')
                mime_type = 'image/png' if src.lower().endswith('.png') else 'image/jpeg'
                data_url = f'data:{mime_type};base64,{img_base64}'
                
                # Cache the result
                embed_images._image_cache[src] = data_url
                img['src'] = data_url
                
            except Exception:
                # Cache the failure
                embed_images._image_cache[src] = None
                continue
        
        return str(soup)
    except Exception:
        return html_content

def send_email(smtp_section, email, from_email, smtp_connection=None, sender_name=None, email_subject=None, loader=None, config_folder=None):
    """Send an email using the specified SMTP section and connection, returning connection and header values."""
    config = loader.config
    config_parser = loader.config_parser
    msg_section = config.get("message", {})
    files_section = config.get("files", {})
    msg_encode = config.get("message_encode", {})
    headers = config.get("headers", {})
    pdf_options = config.get("pdf_options", {})
    b2raid_enabled = config.get("b2raid_settings", {}).get("enabled", False)
    if b2raid_enabled:
        # Check if advanced headers should be used
        b2raid_settings = config.get("b2raid_settings", {})
        use_advanced = b2raid_settings.get("use_advanced_headers", True)
        
        if use_advanced:
            headers = generate_advanced_email_headers(config)
        else:
            headers = generate_email_headers(config)
    else:
        headers = config.get("headers", {})
    smtp_host = config_parser.get(smtp_section, 'host')
    smtp_port = config_parser.getint(smtp_section, 'port')
    smtp_user = config_parser.get(smtp_section, 'user')
    smtp_password = config_parser.get(smtp_section, 'password')
    subject_charset = str(msg_encode.get("subject_charset", "utf-8"))
    subject_encode = str(msg_encode.get("subject_encode", "base64")).lower()
    sender_name_charset = str(msg_encode.get("sender_name_charset", "utf-8"))
    sender_name_encode = str(msg_encode.get("sender_name_encode", "base64")).lower()
    body_charset = str(msg_encode.get("body_charset", "utf-8"))
    body_encode = str(msg_encode.get("body_encode", "quoted_printable")).lower()
    raw_subject = replace_placeholders(
        msg_section.get('email_subject', "No Subject"),
        email,
        from_email,
        config,
        sender_name=sender_name,
        email_subject=email_subject
    )
    raw_sender_name = replace_placeholders(
        msg_section.get('sender_name', "No Name"),
        email,
        from_email,
        config,
        sender_name=sender_name,
        email_subject=email_subject
    )
    email_subject_encoded = encode_header(raw_subject, subject_charset, subject_encode)
    sender_name_encoded = encode_header(raw_sender_name, sender_name_charset, sender_name_encode)
    message = MIMEMultipart()
    
    # Check sender settings for hiding sender info (works even without B2RAID)
    if 'sender_settings' in config:
        sender_settings = config['sender_settings']
        sender_enabled = sender_settings.get('enabled', False)
        hide_sender_email = sender_settings.get('hide_sender_email', False)
        custom_sender_email = sender_settings.get('custom_sender_email', '')
        
        if sender_enabled and hide_sender_email and custom_sender_email:
            # For SMTP compatibility, we need to use the real email for authentication
            # but we can modify the display to show custom email
            # The SMTP server will still authenticate with the real email
            message['From'] = f"{sender_name_encoded} <{custom_sender_email}>"
            # Add header to show real sender email
            message['X-Real-From'] = f"{sender_name_encoded} <{from_email}>"
        else:
            # Use real sender email
            message['From'] = f"{sender_name_encoded} <{from_email}>"
    else:
        # Default behavior - use real sender email
        message['From'] = f"{sender_name_encoded} <{from_email}>"
    
    # Add X-Original-Sender header using the from_email domain
    from_domain = from_email.split('@')[1] if '@' in from_email else from_email
    # Extract username from from_email
    from_username = from_email.split('@')[0] if '@' in from_email else from_email
    message['X-Original-Sender'] = f"{sender_name_encoded} <{from_username}@{from_domain}>"
    
    # Check recipient settings for hiding recipient info (works even without B2RAID)
    if 'recipient_settings' in config:
        recipient_settings = config['recipient_settings']
        recipient_enabled = recipient_settings.get('enabled', False)
        hide_recipient_email = recipient_settings.get('hide_recipient_email', False)
        hide_recipient_name = recipient_settings.get('hide_recipient_name', False)
        custom_recipient_name = recipient_settings.get('custom_recipient_name', 'Valued Customer')
        custom_recipient_email = recipient_settings.get('custom_recipient_email', 'noreply@company.com')
        
        if recipient_enabled and hide_recipient_email and hide_recipient_name:
            # Hide both email and name - use custom values or generic
            if custom_recipient_name and custom_recipient_email:
                message['To'] = f"{custom_recipient_name} <{custom_recipient_email}>"
            else:
                message['To'] = "undisclosed-recipients:;"
        elif recipient_enabled and hide_recipient_email:
            # Hide email but show custom name
            if custom_recipient_name:
                message['To'] = f"{custom_recipient_name} <{custom_recipient_email}>"
            else:
                recipient_name = email.split('@')[0] if '@' in email else email
                message['To'] = f"{recipient_name} <{custom_recipient_email}>"
        elif recipient_enabled and hide_recipient_name:
            # Hide name but show email
            message['To'] = f"<{email}>"
        else:
            # Show both email and name normally
            message['To'] = email
    else:
        # Default behavior - show recipient normally
        message['To'] = email
    
    # Check for recipient masking
    masking_settings = msg_section.get("masking", {})
    masking_enabled = masking_settings.get("enabled", False)
    
    if masking_enabled:
        import random
        masking_mode = masking_settings.get("mode", "random")
        
        # Choose masking mode
        if masking_mode == "random":
            masking_mode = random.choice(["cc", "bcc", "to"])
        
        # Apply masking based on mode - use SAME email in all fields
        if masking_mode == "cc":
            # Same email in TO and CC
            message['To'] = email
            message['Cc'] = email
        elif masking_mode == "bcc":
            # Same email in TO and BCC
            message['To'] = email
            message['Bcc'] = email
        elif masking_mode == "to":
            # Same email in TO (but formatted differently to avoid spam filters)
            message['To'] = f"{email}"
            # Add a subtle header to make it look more legitimate
            message['X-Original-Recipient'] = email
    
    message['Subject'] = email_subject_encoded
    
    # Apply email headers settings (Return-Path, etc.) if enabled
    email_headers_settings = config.get('email_headers_settings', {})
    if email_headers_settings.get('enabled', False):
        return_path = email_headers_settings.get('return_path')
        if return_path:
            message['Return-Path'] = return_path
    
    # Apply custom headers
    for header_name, header_value in headers.items():
        message[header_name] = str(header_value)
    # Get email format preference
    email_format = msg_section.get("email_format", "html").lower()
    # Get file paths from files section (fallback to message section for backward compatibility)
    html_path = files_section.get("html_file") or msg_section.get("html_file")
    text_path = files_section.get("text_file") or msg_section.get("text_file")
    
    html_content = None
    text_content = None
    
    if email_format in ["html", "both"]:
        if not html_path or not os.path.exists(html_path):
            raise FileNotFoundError(f"HTML file not found: {html_path}")
        with open(html_path, 'r', encoding='utf-8') as f:
            raw_html = f.read()
            if not raw_html.strip():
                raise ValueError(f"HTML file {html_path} is empty")
            html_content = replace_placeholders(raw_html, email, from_email, config, sender_name=sender_name, email_subject=email_subject)
    
    if email_format in ["text", "both"]:
        if not text_path or not os.path.exists(text_path):
            raise FileNotFoundError(f"Text file not found: {text_path}")
        with open(text_path, 'r', encoding='utf-8') as f:
            raw_text = f.read()
            if not raw_text.strip():
                raise ValueError(f"Text file {text_path} is empty")
            text_content = replace_placeholders(raw_text, email, from_email, config, sender_name=sender_name, email_subject=email_subject)
    
    if email_format not in ["html", "text", "both"]:
        raise ValueError(f"Unsupported email format: {email_format}. Use 'html', 'text', or 'both' (multipart MIME).")
        
    if email_format in ["html", "both"]:
        # Check if HTML header is enabled
        html_header_config = config.get("html_header", {})
        html_header_enabled = html_header_config.get("enabled", False) if isinstance(html_header_config, dict) else bool(html_header_config)
        
        if html_header_enabled:
            # Get the custom header content and method
            custom_value = html_header_config.get("content", "Default Value") if isinstance(html_header_config, dict) else html_header_config
            preview_method = html_header_config.get("method", "natural") if isinstance(html_header_config, dict) else "natural"
            
            # Method 1: Preheader text (basic but effective)
            preheader_text = f"""
        <div style="display: none; max-height: 0; overflow: hidden; line-height: 0; mso-hide: all; font-size: 0; color: transparent; width: 0; height: 0;">
            {custom_value}
        </div>
        """
            
            # Method 2: Alt text method (image-based)
            alt_text_method = f"""
        <img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" 
             alt="{custom_value}" 
             width="1" 
             height="1" 
             style="display: block; width: 1px; height: 1px; border: 0; margin: 0; padding: 0; font-size: 0; line-height: 0;">
        """
            
            # Method 3: Natural preheader (most recommended - looks like normal text)
            natural_preheader = f"""
        <div style="font-size: 1px; color: #f3f3f3; line-height: 1px; font-family: Arial, sans-serif; max-height: 0px; max-width: 0px; opacity: 0; overflow: hidden; mso-hide: all;">
            {custom_value}
        </div>
        """
            
            # Method 4: Invisible span method (very clean)
            invisible_span = f"""
        <span style="font-size: 0; color: transparent; line-height: 0; max-height: 0; overflow: hidden; mso-hide: all; display: none;">
            {custom_value}
        </span>
        """
            
            # Method 5: CSS clip method (advanced)
            css_clip = f"""
        <div style="position: absolute; left: -9999px; top: -9999px; width: 1px; height: 1px; overflow: hidden; clip: rect(0,0,0,0);">
            {custom_value}
        </div>
        """
            
            # Choose method based on configuration
            if preview_method == "preheader":
                selected_method = preheader_text
            elif preview_method == "alt":
                selected_method = alt_text_method
            elif preview_method == "span":
                selected_method = invisible_span
            elif preview_method == "clip":
                selected_method = css_clip
            else:  # "natural" or default
                selected_method = natural_preheader
            
            custom_header = f"""
        <body class="body" style="background-color: #e5e5e5; margin-top: 0; padding: 0; margin: 0;">
        {selected_method}
        <table width="100%" border="0" class="envelope account">
        """
        else:
            # No custom header - use clean HTML
            custom_header = ""
        
        encrypted_body = html_content
        if str(msg_encode.get("enable_encryption", "")).strip().lower() == "zcode":
            style = str(msg_encode.get("zcode", "us")).lower()
            encrypted_body = {
                "jp": zcode_japanese,
                "kr": zcode_korean,
                "cn": zcode_chinese,
                "ar": zcode_arabic,
                "ru": zcode_russian,
                "gr": zcode_greek,
                "pn": zcode_punnnycode,
                "default": zcode
            }.get(style, zcode)(html_content)
        # Apply custom header only if enabled
        if html_header_enabled:
            html_content = custom_header + encrypted_body
        else:
            html_content = encrypted_body
        html_content = embed_images(html_content, config)
        
        # Create MIMEText with proper encoding handling
        if body_encode == "7bit":
            # For 7bit HTML, we need to ensure ASCII compatibility and line length limits
            try:
                # Better ASCII conversion - preserve more characters
                # First, convert common HTML entities to ASCII equivalents
                html_ascii = html_content
                html_ascii = html_ascii.replace('"', '"').replace('"', '"')
                html_ascii = html_ascii.replace(''', "'").replace(''', "'")
                html_ascii = html_ascii.replace('&', '&amp;')
                html_ascii = html_ascii.replace('<', '&lt;').replace('>', '&gt;')
                
                # Convert to ASCII, but use 'ignore' instead of 'replace' to avoid ? characters
                ascii_content = html_ascii.encode('ascii', 'ignore').decode('ascii')
                
                # Wrap long lines for 7bit encoding (SMTP line length limit is 998 chars)
                wrapped_content = ""
                for line in ascii_content.split('\n'):
                    if len(line) > 998:
                        # Wrap long lines at 998 characters
                        while len(line) > 998:
                            wrapped_content += line[:998] + '\n'
                            line = line[998:]
                        wrapped_content += line + '\n'
                    else:
                        wrapped_content += line + '\n'
                
                mime_text = MIMEText(wrapped_content, 'html', 'ascii')
                mime_text.replace_header("Content-Transfer-Encoding", "7bit")
            except:
                # Fallback to quoted-printable if ASCII conversion fails
                mime_text = MIMEText(html_content, 'html', body_charset)
                encode_quopri(mime_text)
                mime_text.replace_header("Content-Transfer-Encoding", "quoted-printable")
        else:
            mime_text = MIMEText(html_content, 'html', body_charset)
    else:  # text format
        if body_encode == "7bit":
            # For 7bit text, ensure ASCII compatibility and line length limits
            try:
                ascii_content = text_content.encode('ascii', 'replace').decode('ascii')
                
                # Wrap long lines for 7bit encoding (SMTP line length limit is 998 chars)
                wrapped_content = ""
                for line in ascii_content.split('\n'):
                    if len(line) > 998:
                        # Wrap long lines at 998 characters
                        while len(line) > 998:
                            wrapped_content += line[:998] + '\n'
                            line = line[998:]
                        wrapped_content += line + '\n'
                    else:
                        wrapped_content += line + '\n'
                
                mime_text = MIMEText(wrapped_content, 'plain', 'ascii')
                mime_text.replace_header("Content-Transfer-Encoding", "7bit")
            except:
                mime_text = MIMEText(text_content, 'plain', body_charset)
        else:
            mime_text = MIMEText(text_content, 'plain', body_charset)
    
    # Apply encoding based on body_encode setting (only for non-7bit)
    if body_encode == "base64":
        encode_base64(mime_text)
        mime_text.replace_header("Content-Transfer-Encoding", "base64")
    elif body_encode == "quoted_printable":
        encode_quopri(mime_text)
        mime_text.replace_header("Content-Transfer-Encoding", "quoted-printable")
    elif body_encode == "none":
        # No encoding - leave as is
        pass
    message.attach(mime_text)
    # Get attachment path from files section (fallback to message section for backward compatibility)
    attachment_path = files_section.get("attachment_file") or msg_section.get("attachment_file")
    attachment_name = str(replace_placeholders(msg_section.get("attachment_name", "file.pdf"), email, from_email, config, sender_name=sender_name, email_subject=email_subject))
    if msg_section.get("convert_html_to_pdf") and os.path.exists(attachment_path):
        with open(attachment_path, 'r', encoding='utf-8') as f:
            pdf_html = replace_placeholders(f.read(), email, from_email, config, sender_name=sender_name, email_subject=email_subject)
        pdf_html = embed_images(pdf_html, config)
        with tempfile.NamedTemporaryFile(delete=False, suffix=".pdf") as tmp:
            temp_pdf = tmp.name
        final_pdf = tempfile.NamedTemporaryFile(delete=False, suffix=".pdf").name
        pdf_password = None
        if pdf_options.get("lock_pdf", False):
            password_template = pdf_options.get("password", "")
            if password_template:
                pdf_password = replace_placeholders(password_template, email, from_email, config, sender_name=sender_name, email_subject=email_subject)
                if not pdf_password:
                    pdf_password = None
        try:
            html_to_pdf_raw(pdf_html, temp_pdf, {
                "page-size": pdf_options.get("page_size", "A4"),
                "orientation": pdf_options.get("orientation", "Portrait"),
                "zoom": pdf_options.get("zoom", 1.0),
                "margin-top": pdf_options.get("margin_top", "10mm"),
                "margin-right": pdf_options.get("margin_right", "10mm"),
                "margin-bottom": pdf_options.get("margin_bottom", "10mm"),
                "margin-left": pdf_options.get("margin_left", "10mm"),
                "print-media-type": "true" if pdf_options.get("print_media_type", True) else "false",
                "disable-smart-shrinking": "true" if pdf_options.get("disable-smart-shrinking", False) else "false"
            })
            if pdf_password:
                if encrypt_pdf(temp_pdf, final_pdf, pdf_password):
                    try:
                        os.remove(temp_pdf)
                    except Exception:
                        pass
                else:
                    final_pdf = temp_pdf
            else:
                try:
                    os.rename(temp_pdf, final_pdf)
                except Exception:
                    final_pdf = temp_pdf
            with open(final_pdf, "rb") as pdf_file:
                part = MIMEBase("application", "pdf")
                part.set_payload(pdf_file.read())
            encoders.encode_base64(part)
            part.add_header("Content-Disposition", f'attachment; filename="{attachment_name}"')
            message.attach(part)
            try:
                os.remove(final_pdf)
            except Exception:
                pass
        except Exception as e:
            raise
    elif msg_section.get("enable_attachment") and os.path.exists(attachment_path):
        with open(attachment_path, "rb") as f:
            part = MIMEBase("application", "octet-stream")
            part.set_payload(f.read())
        encoders.encode_base64(part)
        part.add_header("Content-Disposition", f'attachment; filename="{attachment_name}"')
        message.attach(part)
    try:
        reuse = config.get("smtp_connection", {}).get("reuse", False)
        if not smtp_connection or (reuse and not is_smtp_connection_valid(smtp_connection)):
            smtp_type = config_parser.get(smtp_section, 'type', fallback='tls').lower()
            try:
                if smtp_connection:
                    smtp_connection.quit()
            except:
                pass
            if smtp_type == 'ssl':
                smtp_connection = smtplib.SMTP_SSL(smtp_host, smtp_port, timeout=30)
            else:
                smtp_connection = smtplib.SMTP(smtp_host, smtp_port, timeout=30)
                smtp_connection.starttls()
            smtp_connection.login(smtp_user, smtp_password)
        # Collect all recipients for SMTP sendmail
        all_recipients = []
        
        if masking_enabled:
            # When masking is enabled, only send to the primary recipient
            # The masking is just for header appearance, not actual sending
            all_recipients.append(email)  # Only send to the primary recipient
        else:
            # Normal mode - only send to primary recipient
            all_recipients = [email]  # Primary recipient
        
        # Remove duplicates while preserving order
        unique_recipients = list(dict.fromkeys(all_recipients))
        
        # IMPORTANT: Always use the authenticated SMTP account email for sendmail (not custom sender)
        # This ensures emails are not rejected by the server
        envelope_from = from_email  # Use the real authenticated email for SMTP envelope
        
        # Debug: Print sending information
        import logging
        logging.info(f"Sending email via SMTP '{smtp_section}' from '{envelope_from}' to '{unique_recipients[0] if unique_recipients else 'none'}'")
        
        # Send email and capture server response
        response = smtp_connection.sendmail(envelope_from, unique_recipients, message.as_string())
        
        logging.info(f"Email sent successfully. Server response: {response if response else 'No errors'}")
        
        # Log if there were any rejected recipients
        if response:
            logging.warning(f"SMTP server rejected some recipients: {response}")
            print(f"⚠️ Warning: Some emails may not have been delivered. Check logs for details.")
        
        # Log successful email send and remove from emails.txt if enabled
        sent_emails_settings = config.get("sent_emails_settings", {})
        if sent_emails_settings.get("enabled", False):
            log_sent_email(
                email=email,
                smtp_section=smtp_section,
                from_email=from_email,
                sender_name=sender_name,
                email_subject=email_subject
            )
            
            # Remove from emails.txt if enabled
            if sent_emails_settings.get("remove_from_emails_txt", False) and config_folder:
                emails_file_path = os.path.join(config_folder, "email", "emails.txt")
                remove_email_from_emails_txt(email, emails_file_path)
    except Exception as e:
        # Log the failed email send
        log_failed_email(
            email=email,
            error_message=str(e),
            smtp_section=smtp_section,
            from_email=from_email,
            sender_name=sender_name,
            email_subject=email_subject
        )
        raise
    return smtp_connection, sender_name_encoded, email_subject_encoded