"""
SMTP Load Balancer with Circuit Breaker Pattern
Automatically disables failed SMTP servers and re-enables them after cooldown.
"""

import time
import threading
import textwrap
import re
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Tuple
from enum import Enum

def parse_time_string(time_str):
    """
    Parse time string in format like '5m', '2m30s', '45s', '1h30m'
    Returns time in seconds
    """
    if isinstance(time_str, (int, float)):
        return time_str
    
    if not isinstance(time_str, str):
        return 300  # Default 5 minutes
    
    total_seconds = 0
    
    # Parse hours
    hours_match = re.search(r'(\d+)h', time_str)
    if hours_match:
        total_seconds += int(hours_match.group(1)) * 3600
    
    # Parse minutes
    minutes_match = re.search(r'(\d+)m', time_str)
    if minutes_match:
        total_seconds += int(minutes_match.group(1)) * 60
    
    # Parse seconds
    seconds_match = re.search(r'(\d+)s', time_str)
    if seconds_match:
        total_seconds += int(seconds_match.group(1))
    
    # If no units found, treat as seconds
    if total_seconds == 0 and time_str.isdigit():
        total_seconds = int(time_str)
    
    return total_seconds if total_seconds > 0 else 300  # Default 5 minutes

class ServerState(Enum):
    HEALTHY = "healthy"
    WARNING = "warning"
    DISABLED = "disabled"
    TESTING = "testing"

class SMTPLoadBalancer:
    """SMTP Load Balancer with Circuit Breaker Pattern"""
    
    def __init__(self, config: dict):
        self.config = config
        self.circuit_breaker_config = config.get("smtp_circuit_breaker", {})
        
        # Server state tracking
        self.server_states: Dict[str, ServerState] = {}
        self.failure_counts: Dict[str, int] = {}
        self.last_failure_times: Dict[str, List[float]] = {}
        self.disable_times: Dict[str, float] = {}
        self.test_attempts: Dict[str, int] = {}
        
        # Load balancing
        self.current_index = 0
        self.server_weights: Dict[str, int] = {}
        self.connection_counts: Dict[str, int] = {}
        
        # Thread safety
        self.lock = threading.Lock()
        
        # Initialize server states
        self._initialize_servers()
    
    def _initialize_servers(self):
        """Initialize all SMTP servers as healthy"""
        # Get SMTP servers from the config - they might be in different locations
        smtp_servers = []
        
        # Try to get from different possible locations in config
        if "smtp_servers" in self.config:
            smtp_servers = self.config["smtp_servers"]
        elif "smtp" in self.config and "servers" in self.config["smtp"]:
            smtp_servers = self.config["smtp"]["servers"]
        
        # If still no servers found, use default names
        if not smtp_servers:
            smtp_servers = ["SMTP1", "SMTP2"]  # Default fallback
        
        for server in smtp_servers:
            self.server_states[server] = ServerState.HEALTHY
            self.failure_counts[server] = 0
            self.last_failure_times[server] = []
            self.connection_counts[server] = 0
            self.test_attempts[server] = 0
    
    def get_next_server(self, available_servers: List[str]) -> Optional[str]:
        """
        Get the next available SMTP server using load balancing strategy.
        
        Args:
            available_servers: List of available SMTP server names
            
        Returns:
            Selected SMTP server name or None if no healthy servers available
        """
        with self.lock:
            # Filter to only healthy servers
            healthy_servers = [s for s in available_servers if self._is_server_healthy(s)]
            
            if not healthy_servers:
                self._handle_no_active_servers(available_servers)
                return None
            
            # Check if any disabled servers should be tested
            self._check_disabled_servers()
            
            # Use round robin for now (can be extended to other strategies)
            return self._round_robin_selection(healthy_servers)
    
    def _is_server_healthy(self, server: str) -> bool:
        """Check if a server is healthy and available"""
        state = self.server_states.get(server, ServerState.HEALTHY)
        return state in [ServerState.HEALTHY, ServerState.WARNING]
    
    def _round_robin_selection(self, healthy_servers: List[str]) -> str:
        """Select next server using round robin"""
        if not healthy_servers:
            return None
        
        # Find current server index in healthy servers list
        try:
            current_index = healthy_servers.index(healthy_servers[self.current_index % len(healthy_servers)])
        except (ValueError, IndexError):
            current_index = 0
        
        # Move to next server
        self.current_index = (current_index + 1) % len(healthy_servers)
        return healthy_servers[self.current_index]
    
    def record_success(self, server: str):
        """Record a successful email send"""
        with self.lock:
            if server in self.server_states:
                # Reset failure count on success
                self.failure_counts[server] = 0
                self.last_failure_times[server] = []
                self.server_states[server] = ServerState.HEALTHY
                self.test_attempts[server] = 0
                
                # Decrement connection count
                if self.connection_counts[server] > 0:
                    self.connection_counts[server] -= 1
    
    def record_failure(self, server: str, error_message: str = ""):
        """Record a failed email send"""
        with self.lock:
            if server not in self.server_states:
                return
            
            current_time = time.time()
            
            # Add failure to history
            self.failure_counts[server] += 1
            self.last_failure_times[server].append(current_time)
            
            # Clean old failures outside time window
            time_window = parse_time_string(self.circuit_breaker_config.get("time_window", "5m"))
            cutoff_time = current_time - time_window
            self.last_failure_times[server] = [
                t for t in self.last_failure_times[server] if t > cutoff_time
            ]
            
            # Check if server should be disabled
            failure_threshold = self.circuit_breaker_config.get("failure_threshold", 3)
            recent_failures = len(self.last_failure_times[server])
            
            if recent_failures >= failure_threshold:
                self._disable_server(server, current_time)
            elif recent_failures >= failure_threshold // 2:
                self.server_states[server] = ServerState.WARNING
    
    def _disable_server(self, server: str, current_time: float):
        """Disable a server due to too many failures"""
        cooldown_period = parse_time_string(self.circuit_breaker_config.get("cooldown_period", "10m"))
        
        # Increase cooldown for repeated failures
        test_attempts = self.test_attempts.get(server, 0)
        cooldown_multiplier = min(2 ** test_attempts, 8)  # Max 8x cooldown
        actual_cooldown = cooldown_period * cooldown_multiplier
        
        # Cap at max cooldown
        max_cooldown = parse_time_string(self.circuit_breaker_config.get("max_cooldown", "1h"))
        actual_cooldown = min(actual_cooldown, max_cooldown)
        
        self.server_states[server] = ServerState.DISABLED
        self.disable_times[server] = current_time + actual_cooldown
        self.test_attempts[server] = test_attempts + 1
        
        # Create ASCII art for server disabled message
        disabled_msg = f"ğŸ”´ SMTP {server} disabled for {actual_cooldown/60:.1f} minutes due to failures"
        disabled_lines = textwrap.wrap(disabled_msg, width=70)
        print("â”‚  â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®     â”‚")
        for line in disabled_lines:
            padded_line = line.ljust(70)
            print(f"â”‚  â”‚  {padded_line}  â”‚     â”‚")
        print("â”‚  â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯     â”‚")
    
    def _handle_no_active_servers(self, available_servers: List[str]):
        """Handle the case when no SMTP servers are active"""
        action = self.circuit_breaker_config.get("no_active_servers_action", "ask")
        
        # Show server status
        print("â”‚  â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®     â”‚")
        print("â”‚  â”‚  ğŸš¨ NO ACTIVE SMTP SERVERS AVAILABLE!                                    â”‚     â”‚")
        print("â”‚  â”‚                                                                           â”‚     â”‚")
        
        # Show server states
        for server in available_servers:
            state = self.server_states.get(server, ServerState.HEALTHY)
            if state == ServerState.DISABLED:
                remaining = self.disable_times.get(server, 0) - time.time()
                if remaining > 0:
                    print(f"â”‚  â”‚  ğŸ”´ {server}: Disabled for {remaining/60:.1f} more minutes              â”‚     â”‚")
                else:
                    print(f"â”‚  â”‚  ğŸŸ  {server}: Ready for testing                                    â”‚     â”‚")
            elif state == ServerState.TESTING:
                print(f"â”‚  â”‚  ğŸŸ  {server}: Testing phase                                          â”‚     â”‚")
            else:
                print(f"â”‚  â”‚  ğŸ”´ {server}: Failed                                                â”‚     â”‚")
        
        print("â”‚  â”‚                                                                           â”‚     â”‚")
        
        if action == "ask":
            print("â”‚  â”‚  What would you like to do?                                            â”‚     â”‚")
            print("â”‚  â”‚  1. Wait for servers to recover (recommended)                         â”‚     â”‚")
            print("â”‚  â”‚  2. Exit the program                                                  â”‚     â”‚")
            print("â”‚  â”‚  3. Continue anyway (may fail)                                        â”‚     â”‚")
            print("â”‚  â”‚                                                                           â”‚     â”‚")
            
            while True:
                try:
                    choice = input("â”‚  â”‚  Enter your choice (1-3): ").strip()
                    if choice == "1":
                        wait_time = parse_time_string(self.circuit_breaker_config.get("wait_time", "5m"))
                        print(f"â”‚  â”‚  â³ Waiting {wait_time/60:.1f} minutes for servers to recover...              â”‚     â”‚")
                        time.sleep(wait_time)
                        break
                    elif choice == "2":
                        print("â”‚  â”‚  ğŸ‘‹ Exiting program...                                           â”‚     â”‚")
                        import sys
                        sys.exit(0)
                    elif choice == "3":
                        print("â”‚  â”‚  âš ï¸  Continuing anyway (may fail)...                              â”‚     â”‚")
                        break
                    else:
                        print("â”‚  â”‚  âŒ Invalid choice. Please enter 1, 2, or 3.                    â”‚     â”‚")
                except KeyboardInterrupt:
                    print("\nâ”‚  â”‚  ğŸ‘‹ Exiting program...                                           â”‚     â”‚")
                    import sys
                    sys.exit(0)
        
        elif action == "wait":
            wait_time = parse_time_string(self.circuit_breaker_config.get("wait_time", "5m"))
            print(f"â”‚  â”‚  â³ Auto-waiting {wait_time/60:.1f} minutes for servers to recover...        â”‚     â”‚")
            time.sleep(wait_time)
        
        elif action == "exit":
            print("â”‚  â”‚  ğŸ‘‹ Auto-exiting due to no active servers...                        â”‚     â”‚")
            import sys
            sys.exit(0)
        
        print("â”‚  â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯     â”‚")
    
    def _check_disabled_servers(self):
        """Check if any disabled servers should be tested"""
        current_time = time.time()
        
        for server, disable_time in self.disable_times.items():
            if current_time >= disable_time and self.server_states[server] == ServerState.DISABLED:
                self.server_states[server] = ServerState.TESTING
                # Create ASCII art for testing phase message
                testing_msg = f"ğŸŸ  SMTP {server} entering testing phase"
                testing_lines = textwrap.wrap(testing_msg, width=70)
                print("â”‚  â•­â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•®     â”‚")
                for line in testing_lines:
                    padded_line = line.ljust(70)
                    print(f"â”‚  â”‚  {padded_line}  â”‚     â”‚")
                print("â”‚  â•°â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â•¯     â”‚")
    
    def is_server_available_for_testing(self, server: str) -> bool:
        """Check if a server is available for testing after cooldown"""
        return self.server_states.get(server) == ServerState.TESTING
    
    def get_server_status(self) -> Dict[str, dict]:
        """Get current status of all servers"""
        with self.lock:
            status = {}
            current_time = time.time()
            
            for server in self.server_states:
                state = self.server_states[server]
                failure_count = self.failure_counts[server]
                recent_failures = len(self.last_failure_times[server])
                
                # Calculate time until next test
                next_test = None
                if state == ServerState.DISABLED and server in self.disable_times:
                    remaining = self.disable_times[server] - current_time
                    if remaining > 0:
                        next_test = f"{remaining/60:.1f} min"
                
                status[server] = {
                    "state": state.value,
                    "failure_count": failure_count,
                    "recent_failures": recent_failures,
                    "next_test": next_test,
                    "connection_count": self.connection_counts.get(server, 0)
                }
            
            return status
    
    def get_recommended_thread_count(self, available_servers: List[str], max_threads: int) -> int:
        """
        Get recommended thread count based on healthy servers.
        
        Args:
            available_servers: List of available SMTP server names
            max_threads: Maximum allowed threads
            
        Returns:
            Recommended thread count (1 to max_threads)
        """
        with self.lock:
            # Count healthy servers
            healthy_servers = [s for s in available_servers if self._is_server_healthy(s)]
            healthy_count = len(healthy_servers)
            
            if healthy_count == 0:
                return 1  # Minimum 1 thread even if no healthy servers
            
            # Don't exceed max_threads or healthy server count
            recommended = min(healthy_count, max_threads)
            
            # Ensure at least 1 thread
            return max(1, recommended)
    
    def get_status_display(self) -> str:
        """Get a formatted status display"""
        status = self.get_server_status()
        
        if not status:
            return "No SMTP servers configured"
        
        # Create status table
        lines = ["â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”"]
        lines.append("â”‚ Server  â”‚ Status   â”‚ Failures    â”‚ Next Test    â”‚")
        lines.append("â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤")
        
        for server, info in status.items():
            state_emoji = {
                "healthy": "ğŸŸ¢",
                "warning": "ğŸŸ¡", 
                "disabled": "ğŸ”´",
                "testing": "ğŸŸ "
            }.get(info["state"], "âšª")
            
            state_text = f"{state_emoji} {info['state'].upper()}"
            failures = f"{info['recent_failures']}/{info['failure_count']}"
            next_test = info["next_test"] or "-"
            
            lines.append(f"â”‚ {server:<7} â”‚ {state_text:<8} â”‚ {failures:<11} â”‚ {next_test:<12} â”‚")
        
        lines.append("â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜")
        
        return "\n".join(lines)
    
    def reset_server(self, server: str):
        """Manually reset a server to healthy state"""
        with self.lock:
            if server in self.server_states:
                self.server_states[server] = ServerState.HEALTHY
                self.failure_counts[server] = 0
                self.last_failure_times[server] = []
                self.disable_times[server] = 0
                self.test_attempts[server] = 0
                print(f"âœ… SMTP {server} manually reset to healthy")

# Global load balancer instance
_load_balancer: Optional[SMTPLoadBalancer] = None

def get_load_balancer(config: dict) -> SMTPLoadBalancer:
    """Get or create the global load balancer instance"""
    global _load_balancer
    if _load_balancer is None:
        _load_balancer = SMTPLoadBalancer(config)
    return _load_balancer

def reset_load_balancer():
    """Reset the global load balancer instance"""
    global _load_balancer
    _load_balancer = None
